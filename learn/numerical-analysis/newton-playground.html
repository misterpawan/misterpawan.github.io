<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Newton Interpolation (Divided Differences)</title>
    <style>
        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }

        h2 {
            color: #444;
            margin-bottom: 5px;
        }

        h4 {
            color: #666;
            margin-top: 0;
            font-weight: normal;
        }

        .controls {
            margin-bottom: 15px;
            text-align: center;
            max-width: 650px;
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .instruction {
            font-size: 0.95em;
            color: #555;
        }

        .highlight {
            color: #9b59b6;
            font-weight: bold;
        }

        canvas {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            /* Crucial for correct coordinate calculation on zoomed screens/high-DPI */
            width: 800px;
            height: 500px;
        }

        .info-panel {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            width: 800px;
        }

        .info-box {
            flex: 1;
            background: #e8f4f8;
            padding: 15px;
            border-radius: 6px;
            font-size: 14px;
            border-left: 4px solid #3498db;
        }

        .coef-box {
            border-left-color: #9b59b6;
            font-family: 'Courier New', monospace;
            background: #f4ecf7;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(1px);
        }
    </style>
</head>

<body>

    <h2>Newton Interpolation Playground</h2>
    <h4>Uses Divided Differences to build the polynomial incrementally.</h4>

    <div class="controls">
        <div class="instruction">
            <strong>Click points</strong> on the graph to toggle them selection state.<br>
            The <span class="highlight">purple curve</span> is the Newton polynomial built using only the teal selected
            points.
        </div>
    </div>

    <canvas id="plotCanvas" width="1600" height="1000"></canvas>

    <div class="info-panel">
        <div class="info-box" id="statusText">
            Status loading...
        </div>
        <div class="info-box coef-box" id="coefText">
            Coefficients c_j loading...
        </div>
    </div>

    <button onclick="generateData()">Generate New Random Data</button>

    <script>
        const canvas = document.getElementById('plotCanvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('statusText');
        const coefText = document.getElementById('coefText');

        // High-DPI canvas setup
        const scale = window.devicePixelRatio;
        // The width/height in CSS pixels
        const displayWidth = 800;
        const displayHeight = 500;
        // PADDING in CSS pixels
        const PADDING = 60;

        // State
        const NUM_POINTS = 5;
        const POINT_RADIUS = 10; // Larger touch target
        let points = []; // Array of {t, y, active}

        // Helper: Map data space (0-1) to CSS pixel space
        function toScreen(t, y) {
            const w = displayWidth - 2 * PADDING;
            const h = displayHeight - 2 * PADDING;
            return {
                x: PADDING + t * w,
                y: displayHeight - (PADDING + y * h)
            };
        }

        // ==========================================
        // CORE NEWTON INTERPOLATION MATH
        // ==========================================

        // 1. Calculate Divided Differences (The coefficients c_j)
        // Returns an array [c0, c1, ..., ck]
        function calculateDividedDifferences(activePoints) {
            let n = activePoints.length;
            if (n === 0) return [];

            // Initialize table with y-values (this will hold the diagonal results)
            let coef = activePoints.map(p => p.y);

            // Compute divided differences in-place using a 1D array approach
            for (let j = 1; j < n; j++) {
                for (let i = n - 1; i >= j; i--) {
                    // f[t_{i-j}...t_i] = (f[t_{i-j+1}...t_i] - f[t_{i-j}...t_{i-1}]) / (t_i - t_{i-j})
                    coef[i] = (coef[i] - coef[i - 1]) / (activePoints[i].t - activePoints[i - j].t);
                }
            }
            // After the loops, 'coef' holds the diagonal elements: [f[t0], f[t0,t1], f[t0,t1,t2]...]
            return coef;
        }

        // 2. Evaluate Newton Polynomial using coefficients
        // P(t) = c0 + c1(t-t0) + c2(t-t0)(t-t1) + ...
        function evaluateNewtonPoly(tVal, coefficients, activePoints) {
            let n = coefficients.length;
            if (n === 0) return 0;

            let result = coefficients[0]; // c0

            for (let i = 1; i < n; i++) {
                let productTerm = coefficients[i]; // ci
                // Multiply by (t - t0) * (t - t1) * ... * (t - t_{i-1})
                for (let j = 0; j < i; j++) {
                    productTerm *= (tVal - activePoints[j].t);
                }
                result += productTerm;
            }
            return result;
        }

        // ==========================================
        // APP LOGIC
        // ==========================================

        function generateData() {
            points = [];
            let t_values = Array.from({ length: NUM_POINTS }, () => Math.random()).sort((a, b) => a - b);

            for (let i = 0; i < NUM_POINTS; i++) {
                // Ensure t values aren't too close to edges for better visuals
                let t = 0.05 + t_values[i] * 0.9;
                let y = 0.15 + Math.random() * 0.7; // Keep y centered vertically

                points.push({ t, y, active: true });
            }
            draw();
        }

        function draw() {
            // Reset transform and clear for high-DPI rendering
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.scale(scale, scale);

            const activePoints = points.filter(p => p.active);

            // ---- MATH STEP 1: Calculate Coefficients ----
            const coefficients = calculateDividedDifferences(activePoints);

            // Update UI Text
            statusText.innerHTML = `<strong>Status:</strong> ${activePoints.length} points selected. Polynomial Degree: ${Math.max(0, activePoints.length - 1)}`;

            if (coefficients.length > 0) {
                // Format coefficients for display (e.g., "c₀=0.23, c₁=-1.45...")
                const coefString = coefficients.map((c, idx) => `c<sub>${idx}</sub>=${c.toFixed(2)}`).join(',  ');
                coefText.innerHTML = `<strong>Divided Differences (Coefficients):</strong><br>${coefString}`;
            } else {
                coefText.innerHTML = "Select points to calculate coefficients.";
            }


            // Draw Grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i <= 5; i++) {
                let y = PADDING + (displayHeight - 2 * PADDING) * (i / 5);
                ctx.moveTo(PADDING, y); ctx.lineTo(displayWidth - PADDING, y);
            }
            ctx.stroke();

            // ---- MATH STEP 2: Draw Curve by evaluating polynomial ----
            if (activePoints.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = '#9b59b6'; // Purple curve for Newton
                ctx.lineWidth = 4;
                ctx.lineJoin = 'round';

                // Draw across the width
                for (let px = PADDING; px <= displayWidth - PADDING; px += 2) {
                    // Map screen X back to data 't'
                    let t = (px - PADDING) / (displayWidth - 2 * PADDING);

                    // Evaluate y using Newton form
                    let y = evaluateNewtonPoly(t, coefficients, activePoints);

                    // Map data 'y' back to screen coordinate
                    let pos = toScreen(t, y);

                    if (px === PADDING) ctx.moveTo(pos.x, pos.y);
                    else ctx.lineTo(pos.x, pos.y);
                }
                ctx.stroke();
            }

            // Draw Points
            points.forEach(p => {
                let pos = toScreen(p.t, p.y);

                // Outer glow/stroke
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, POINT_RADIUS + 3, 0, Math.PI * 2);
                ctx.fillStyle = p.active ? 'rgba(52, 152, 219, 0.3)' : 'transparent';
                ctx.fill();

                // Main dot point
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, POINT_RADIUS, 0, Math.PI * 2);
                if (p.active) {
                    ctx.fillStyle = '#3498db'; // Teal for active
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                } else {
                    ctx.fillStyle = '#bdc3c7'; // Grey for inactive
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                }
                ctx.fill();
                ctx.stroke();
            });
        }

        // Handle Interactions
        canvas.addEventListener('mousedown', handleInteract);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // prevent scrolling
            handleInteract(e.touches[0]);
        }, { passive: false });

        function handleInteract(e) {
            // Get click coordinates relative to CSS display size
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Find closest point
            points.forEach(p => {
                let pos = toScreen(p.t, p.y);
                // Use a slightly larger hit area than the visual radius
                let dist = Math.sqrt((clickX - pos.x) ** 2 + (clickY - pos.y) ** 2);
                if (dist <= POINT_RADIUS * 1.5) {
                    p.active = !p.active;
                    draw();
                }
            });
        }

        // Init
        generateData();

    </script>
</body>

</html>